---
title: "p8105_hw6_xy2672"
output: github_document
date: "2025-12-02"
---

```{r setup, include=FALSE}
library(tidyverse)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```

Load Key packages

```{r}
library(tidyverse)
library(p8105.datasets)
```


## Problem 1

import dataset and clean it
```{r}
homicide_df = read_csv("data/homicide-data.csv") |> 
  mutate(
    city_state = str_c(city, ", ", state),
    resolved = as.numeric(disposition == "Closed by arrest"),
    victim_age = as.numeric(victim_age)
  ) |> 
  filter(
    !city_state %in% c("Dallas, TX", "Phoenix, AZ", "Kansas City, MO", "Tulsa, AL"),
    victim_race %in% c("White", "Black"),
    !is.na(victim_age)
  )
```

Create a baltimore df

```{r}
baltimore_df = 
  homicide_df |> 
  filter(city_state == "Baltimore, MD")

baltimore_glm_fit = 
  baltimore_df |> 
  glm(resolved ~ victim_age + victim_sex + victim_race, data = _, family = binomial())

baltimore_results =
  baltimore_glm_fit |> 
  broom::tidy(conf.int = TRUE) |> 
  mutate(
    OR = exp(estimate),
    CI_low = exp(conf.low),
    CI_high = exp(conf.high)
  ) |> 
  filter(term == "victim_sexMale") |> 
  select(term, OR, CI_high, CI_low)
```


Run glm for each city

```{r}
city_OR_df =
  homicide_df |>
  nest(data = -city_state) |>
  mutate(
    glm_fit = map(
      data,
      ~ glm(
          resolved ~ victim_age + victim_sex + victim_race,
          data = .x,
          family = binomial()
        )
    ),
    results = map(
      glm_fit,
      ~ broom::tidy(.x, conf.int = TRUE) |>
        mutate(
          OR = exp(estimate),
          CI_low = exp(conf.low),
          CI_high = exp(conf.high)
        ) |>
        filter(term == "victim_sexMale") |>
        select(term, OR, CI_low, CI_high)
    )
  ) |>
  select(city_state, results) |>
  unnest(results)
```

Create plot

```{r}
city_OR_df |>
  mutate(city_state = fct_reorder(city_state, OR)) |>
  ggplot(aes(x = city_state, y = OR)) +
  geom_point() +
  geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0) +
  labs(
    x = "City",
    y = "Adjusted OR (Male vs Female)"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

From the plot, `city_state` like New York, NY; Baton Rough, LA; and Omaha, NE; have OR less than 1, suggesting that male victims are less likely to be solved than female victims. In contrast, `city_state` like Albuquerque, NM; Stockton, CA; and Fresno, CA; have OR greater than 1, suggesting that male victims are more likely to be solved than female victims. Overall speaking, solve rates vary substantially depending on local conditions, and since there are many estimates have wide CIs that include 1, it is hard to conclude that whether sex affects solve rates in many `city_state`.

## Problem 2

load weather dataset
```{r}
library(p8105.datasets)
data("weather_df")

set.seed(1)
```

Create a bootstrap function for one sample

```{r}
boot_sample = function(df) {
  sample_frac(df, replace = TRUE)
}
```

5000 boot_strap samples
```{r}
boot_straps =
  tibble(strap_number = 1:5000) |>
  mutate(
    strap_sample = map(strap_number, \(i) boot_sample(weather_df))
  )

```

Get the r2 and beta_ratio

```{r}
boot_results =
  boot_straps |>
  mutate(
    models = map(strap_sample, \(df) lm(tmax ~ tmin + prcp, data = df)),
    glanced = map(models, broom::glance),
    tidied  = map(models, broom::tidy)
  ) |> 
  mutate(
  r2 = map_dbl(glanced, \(x) x$r.squared),
  beta1 = map_dbl(tidied, \(df) df |> filter(term == "tmin") |> pull(estimate)),
  beta2 = map_dbl(tidied, \(df) df |> filter(term == "prcp") |> pull(estimate)),
  beta_ratio = beta1 / beta2
  )|>
  select(r2, beta_ratio)
```

Plot the distribution of R squared

```{r}
boot_results |>
  ggplot(aes(x = r2)) +
  geom_histogram() +
  labs(
    title = "Distribution of R²",
    x = "R²",
    y = "Count"
  )
```

The bootstrap distribution of R² is approximately symmetric and bell-shaped, centered around 0.9425, with most values falling between approximately 0.935 and 0.945. This indicates that the regression model using tmin and prcp as predictors explains a very large proportion of the variability in tmax consistently. 

Plot the distribution of beta1 / beta2

```{r}
boot_results |>
  ggplot(aes(x = beta_ratio)) +
  geom_histogram() +
  labs(
    title = "Distribution of Beta1 / Beta2",
    x = "Beta_ratio",
    y = "Count"
  ) 
```

The bootstrap distribution of the ratio beta1 / beta2 is strongly right-skewed and entirely negative, with most values falling between approximately –250 and –150. 

Get the 95% CI from estimates:

```{r}
boot_ci =
  boot_results |>
  summarize(
    r2_low   = quantile(r2, 0.025),
    r2_high  = quantile(r2, 0.975),
    br_low   = quantile(beta_ratio, 0.025),
    br_high  = quantile(beta_ratio, 0.975)
  ) |> 
  knitr::kable()

boot_ci
```

## Problem 3

Load dataset and clean:

```{r}
birthweight_df = read_csv("data/birthweight.csv") |> 
  mutate(
    babysex = factor(babysex, levels = c(1,2), labels = c("male", "female")),
    frace   = factor(frace, levels = c(1, 2, 3, 4, 8, 9),
                     labels = c("White", "Black", "Asian", "Puerto Rican", "Other", "Unknown")),
    mrace   = factor(mrace, levels = c(1, 2, 3, 4, 8),
                     labels = c("White", "Black", "Asian", "Puerto Rican", "Other")),
    malform = factor(malform, levels = c(0, 1), labels = c("absent", "present"))
  ) |> 
  drop_na()
```

propose a model:

To propose a regression model for birthweight, I started by considering predictors that may biologically relate to fetus growth. 
`blength` Infant length birth is included first because birth length is highly correlated with overall size at birth.
`gaweeks` Babies born earlier generally weigh less, even if healthy, so gestational age is also included. 
`babysex` Baby sex is included as male infants may be heavier than female infants
`wtgain` Weight gain of mother during pregnancy can be a predictor of infant weights as it reflect mother's nutrition
`mrace` Mother's race is included as a socioeconomic factor to better comprehensively reflect infant birth weight.

```{r}
model1 = lm(bwt ~ blength + babysex + wtgain + gaweeks + mrace, data = birthweight_df)
```

Create residual plots:

```{r}
library(modelr)

birthweight_df |>
  add_predictions(model1) |>
  add_residuals(model1) |>
  ggplot(aes(x = pred, y = resid)) +
  geom_point(alpha = .5) +
  labs(
    x = "Fitted values",
    y = "Residuals",
    title = "Residuals vs fitted values for proposed birthweight model"
  )
```

Other two models:

```{r}
model_main =
  birthweight_df |>
  lm(bwt ~ blength + gaweeks, data = _)

model_interact =
  birthweight_df |>
  lm(bwt ~ bhead * blength * babysex, data = _)
```

Compare the models:

```{r}
set.seed(1)

cv_df = crossv_mc(birthweight_df, n = 100) |> 
  mutate(
    train = map(train, as.tibble),
    test = map(test, as.tibble)
  ) |> 
  mutate(
    fit_1 = map(train, \(df) lm(bwt ~ blength + babysex + wtgain + gaweeks + mrace, data = df)),
    fit_main = map(train, \(df) lm(bwt ~ blength + gaweeks, data = df)),
    fit_interact = map(train, \(df) lm(bwt ~ bhead * blength * babysex, data = df))
  ) |> 
  mutate(
    rmse_1 = map2_dbl(fit_1, test, rmse),
    rmse_main = map2_dbl(fit_main, test, rmse),
    rmse_interact = map2_dbl(fit_interact, test, rmse),
  )
  
```

Make a comparison plot:

```{r}
cv_df |> 
  select(starts_with("rmse")) |> 
  pivot_longer(
    everything(),
    names_to = "model",
    values_to = "rmse",
    names_prefix = "rmse_"
  ) |> 
  ggplot(aes(x = model, y = rmse)) + 
  geom_violin()
```

Based on the comparison plot, the interact model has the best predictive performance as it has the lowest RMSE distribution. 

